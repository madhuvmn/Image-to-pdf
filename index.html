<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDF Report Generator (Images 1-20)</title>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: #f3f4f6;
      padding: 24px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    .container {
      background: #ffffff;
      padding: 20px 24px;
      border-radius: 10px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.12);
      max-width: 420px;
      width: 100%;
    }

    h1 {
      font-size: 18px;
      margin-bottom: 12px;
      text-align: center;
    }

    p.subtitle {
      font-size: 13px;
      color: #6b7280;
      margin-bottom: 20px;
      text-align: center;
    }

    .form-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .form-row label {
      font-size: 13px;
      color: #374151;
      min-width: 48px;
    }

    .form-row input[type="number"] {
      flex: 1;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      outline: none;
    }

    .form-row input[type="number"]:focus {
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
    }

    .hint {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 16px;
    }

    .btn {
      width: 100%;
      border: none;
      border-radius: 999px;
      padding: 9px 14px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      background: #2563eb;
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .note {
      margin-top: 14px;
      font-size: 11px;
      color: #6b7280;
    }

    .note code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: #f3f4f6;
      padding: 1px 4px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Generate PDF Report</h1>
    <p class="subtitle">
      Uses images <code>image1</code> to <code>image20</code> from this folder.
    </p>

    <div class="form-row">
      <label for="fromNumber">From</label>
      <input id="fromNumber" type="number" min="1" max="20" value="1" />
    </div>

    <div class="form-row">
      <label for="toNumber">To</label>
      <input id="toNumber" type="number" min="1" max="20" value="4" />
    </div>

    <div class="hint">
      Enter a range between <strong>1</strong> and <strong>20</strong>. One section per image, 4 sections per A4 page.
    </div>

    <button class="btn" id="generateBtn">
      <span>Generate PDF</span>
    </button>

    <div class="note">
      Place this HTML file and your image files
      (<code>image1.jpg</code> â€¦ <code>image20.jpg</code>) in the same folder.
    </div>
  </div>

  <!-- jsPDF from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Configuration: change extension if needed (e.g. ".png")
    const MAX_IMAGES = 20;
    const IMAGE_PREFIX = "image";
    const IMAGE_EXTENSION = ".jpg";

    const fromInput = document.getElementById("fromNumber");
    const toInput = document.getElementById("toNumber");
    const generateBtn = document.getElementById("generateBtn");

    generateBtn.addEventListener("click", () => {
      generatePdfFromRange().catch((err) => {
        console.error(err);
        alert("Something went wrong while generating the PDF.");
      });
    });

    async function generatePdfFromRange() {
      const from = parseInt(fromInput.value, 10);
      const to = parseInt(toInput.value, 10);

      if (Number.isNaN(from) || Number.isNaN(to)) {
        alert("Please enter both From and To numbers.");
        return;
      }
      if (from < 1 || to < 1 || from > MAX_IMAGES || to > MAX_IMAGES) {
        alert(`Range must be between 1 and ${MAX_IMAGES}.`);
        return;
      }
      if (from > to) {
        alert("From number cannot be greater than To number.");
        return;
      }

      generateBtn.disabled = true;
      generateBtn.textContent = "Generating...";

      const indices = [];
      for (let i = from; i <= to; i++) {
        indices.push(i);
      }

      // Load images for these indices
      const { imageDataMap, missing } = await loadImages(indices);

      // Create PDF
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF("p", "pt", "a4");

      drawReport(doc, indices, imageDataMap);

      // Show missing images alert, if any
      if (missing.length > 0) {
        alert(buildMissingMessage(missing));
      }

      doc.save("report.pdf");

      generateBtn.disabled = false;
      generateBtn.textContent = "Generate PDF";
    }

    function buildMissingMessage(missingArray) {
      const parts = missingArray.map((idx) => `image${idx}`);
      if (parts.length === 1) {
        return `${parts[0]} was not available.`;
      }
      if (parts.length === 2) {
        return `${parts[0]} and ${parts[1]} were not available.`;
      }
      const last = parts.pop();
      return `${parts.join(", ")} and ${last} were not available.`;
    }

    // Load all images in the range and return dataURLs (and natural sizes)
    async function loadImages(indices) {
      const imageDataMap = {}; // index -> { dataUrl, width, height }
      const missing = [];

      const promises = indices.map((idx) => loadSingleImage(idx));
      const results = await Promise.all(promises);

      for (const result of results) {
        if (result.missing) {
          missing.push(result.index);
        } else if (result.dataUrl) {
          imageDataMap[result.index] = {
            dataUrl: result.dataUrl,
            width: result.width,
            height: result.height,
          };
        }
      }

      return { imageDataMap, missing };
    }

    function loadSingleImage(index) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = function () {
          // Draw image onto canvas and get dataURL
          const canvas = document.createElement("canvas");
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);
          const dataUrl = canvas.toDataURL("image/jpeg");

          resolve({
            index,
            dataUrl,
            width: img.naturalWidth,
            height: img.naturalHeight,
            missing: false,
          });
        };
        img.onerror = function () {
          resolve({
            index,
            dataUrl: null,
            width: 0,
            height: 0,
            missing: true,
          });
        };

        img.src = `${IMAGE_PREFIX}${index}${IMAGE_EXTENSION}`;
      });
    }

    // Draw the PDF content: 4 sections per page (2 rows x 2 columns)
    function drawReport(doc, indices, imageDataMap) {
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();

      const margin = 24; // page margin
      const gap = 12; // gap between sections

      const contentWidth = pageWidth - margin * 2;
      const contentHeight = pageHeight - margin * 2;

      const sectionWidth = (contentWidth - gap) / 2;
      const sectionHeight = (contentHeight - gap) / 2;

      let sectionCounter = 0;

      indices.forEach((imgIndex, i) => {
        const sectionIndexOnPage = sectionCounter % 4;

        // New page after each 4 sections (except first)
        if (sectionIndexOnPage === 0 && i !== 0) {
          doc.addPage();
        }

        const row = Math.floor(sectionIndexOnPage / 2);
        const col = sectionIndexOnPage % 2;

        const x = margin + col * (sectionWidth + gap);
        const y = margin + row * (sectionHeight + gap);

        const imgData = imageDataMap[imgIndex] || null;

        drawSection(doc, {
          x,
          y,
          width: sectionWidth,
          height: sectionHeight,
          imageIndex: imgIndex,
          imageInfo: imgData,
        });

        sectionCounter++;
      });
    }

    function drawSection(doc, config) {
      const { x, y, width, height, imageIndex, imageInfo } = config;

      const outerRadius = 4;

      // Outer section border
      doc.setDrawColor(180);
      doc.setLineWidth(0.5);
      doc.roundedRect(x, y, width, height, outerRadius, outerRadius, "S");

      const padding = 8;
      const innerX = x + padding;
      const innerY = y + padding;
      const innerW = width - padding * 2;
      const innerH = height - padding * 2;

      const verticalGap = 6;

      // Card layout inside the section
      const headerHeight = innerH * 0.40;
      const remainingH = innerH - headerHeight - 2 * verticalGap;
      const otherCardHeight = remainingH / 2;

      // Card 1: Header Image card
      const card1X = innerX;
      const card1Y = innerY;
      const card1W = innerW;
      const card1H = headerHeight;

      // Card 2
      const card2X = innerX;
      const card2Y = card1Y + card1H + verticalGap;
      const card2W = innerW;
      const card2H = otherCardHeight;

      // Card 3
      const card3X = innerX;
      const card3Y = card2Y + card2H + verticalGap;
      const card3W = innerW;
      const card3H = otherCardHeight;

      // Draw cards
      doc.setDrawColor(200);
      doc.setFillColor(249, 250, 251);

      // Card 1 border (no fill)
      doc.rect(card1X, card1Y, card1W, card1H);

      // Card 2
      doc.rect(card2X, card2Y, card2W, card2H);
      // Card 3
      doc.rect(card3X, card3Y, card3W, card3H);

      // Section title at top-left
      doc.setFont("helvetica", "bold");
      doc.setFontSize(9);
      doc.text(`Section for image${imageIndex}`, innerX, innerY - 3);

      // --- Draw image in Card 1 ---
      if (imageInfo && imageInfo.dataUrl) {
        const maxImgW = card1W - 6;
        const maxImgH = card1H - 6;

        const naturalW = imageInfo.width || maxImgW;
        const naturalH = imageInfo.height || maxImgH;

        const scale = Math.min(maxImgW / naturalW, maxImgH / naturalH);
        const drawW = naturalW * scale;
        const drawH = naturalH * scale;

        const imgX = card1X + (card1W - drawW) / 2;
        const imgY = card1Y + (card1H - drawH) / 2;

        doc.addImage(imageInfo.dataUrl, "JPEG", imgX, imgY, drawW, drawH);
      } else {
        // Optional: text if image missing (in addition to alert)
        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.text(
          `image${imageIndex} not loaded`,
          card1X + 4,
          card1Y + 14
        );
      }

      // --- Card 2 text ---
      doc.setFont("helvetica", "bold");
      doc.setFontSize(9);
      doc.text("Card 2", card2X + 4, card2Y + 12);

      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);
      doc.text(
        "Details or summary for this section go here.",
        card2X + 4,
        card2Y + 24
      );

      // --- Card 3 text ---
      doc.setFont("helvetica", "bold");
      doc.setFontSize(9);
      doc.text("Card 3", card3X + 4, card3Y + 12);

      doc.setFont("helvetica", "normal");
      doc.setFontSize(8);
      doc.text(
        "Additional info, notes, or metrics go here.",
        card3X + 4,
        card3Y + 24
      );
    }
  </script>
</body>
</html>
